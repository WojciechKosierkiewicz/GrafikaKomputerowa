<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0061)http://www.zsk.ict.pwr.wroc.pl/zsk/dyd/intinz/gk/lab/cw_4_dz/ -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Zakład Systemów Komputerowych</title>
    <script type="text/javascript" src="./GK Lab4 - Zakład Systemów Komputerowych_files/stats.js"></script>
    
    <meta http-equiv="Content-Style-Type" content="text/css">
    <meta name="description" content="Zakład Systemów Komputerowych">
    <meta name="keywords" content="zakład systemów komputerowych, zsk, politechnika wroc?awska, pwr, wroc?aw, ict, instytut cybernetyki technicznej, instytut informatyki, automatyki i robotyki">
    <meta name="robots" content="index, follow">
    <meta name="author" content="Tomasz Walkowiak, Mirosław Szymczyk">
    <meta name="copyright" content="Copyright © 2020 Zakład Systemów Komputerowych">
    <link href="./GK Lab4 - Zakład Systemów Komputerowych_files/main.css" rel="stylesheet" type="text/css">
    <link rel="shortcut icon" href="http://www.zsk.ict.pwr.wroc.pl/zsk/css/001/favicon.ico" type="image/x-icon">
  </head>

  <body id="cms" onload="stats(329)">
    <div id="loginout">
      <form method="post" action="http://www.zsk.ict.pwr.wroc.pl/zsk/login.do">
        <div class="headlog">
          <input name="userLogin" type="text" value="">
          <input name="userPassword" type="password" value="">
          <input id="submit" type="submit" value="Zaloguj">
        </div>
      </form>
    </div>
    <div id="container">
      <div id="header">
        <div class="mainMenu">
          <div><p><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/projekty/">Działalność naukowo-badawcza</a></p></div>
          <div><p><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/dyd/">Działalność dydaktyczna</a></p></div>
          <div><p><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/pracownicy/">Pracownicy</a></p></div>
          <div><p><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/news/">Aktualności</a></p></div>
          <div><p><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/eng/">English version</a></p></div>
        </div>
      </div>
      <div id="left">
        <div class="catalogMenu">
          <div><p><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/dyd/intinz/gk/lab/">..</a></p></div>
        </div>
      </div>
      <div id="content">
        <div class="content">
          <div class="itemPath"><span><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/dyd/">Działalność dydaktyczna</a></span><span><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/dyd/intinz/">Studia inżynierskie</a></span><span><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/dyd/intinz/gk/">Grafika komputerowa</a></span><span><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/dyd/intinz/gk/lab/">Laboratorium - studia stacjonarne</a></span><span><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/dyd/intinz/gk/lab/cw_4_dz/">Ćwiczenie 4</a></span></div>
          <div class="articleTitle">Ćwiczenie 4</div>
          <div class="articleDescription">OpenGL - interakcja z użytkownikiem</div>
          <div class="articleContent"><h4 class="MsoNormal przedmioty">1. Cel ćwiczenia &nbsp;</h4><div align="justify">&nbsp; Ćwiczenie ma za zadanie pokazać, jak przy pomocy funkcji biblioteki <em>OpenGL</em> z rozszerzeniem <em>GLUT</em> można zrealizować prostą interakcję, polegające na sterowaniu ruchem obiektu i położeniem obserwatora w przestrzeni 3D. Do sterowania służyla będzie mysz. Ponadto zostaną zilustrowanie sposoby prezentacji obiektów trójwymiarowych w rzucie perspektywicznym.</div><h4 class="MsoNormal przedmioty">2. Rzutowanie perspektywiczne</h4><p class="MsoNormal przedmioty">&nbsp; W poprzednim ćwiczeniu stosowano rzutowanie równoległe, a dokładniej jego szczególny przypadek zwany rzutem ortograficznym. Do realizacji rzutowania ortograficznego służyfunkcja<span style="font-family: &#39;courier new&#39;, courier;"> <strong>glOrtho()</strong></span>. W rzucie ortograficznym rzutnia, czyli płaszczyzna na której powstawał obraz, była równoległa do płaszczyzny tworzonej przez osie <span style="font-family: &#39;courier new&#39;, courier;">x </span>i <span style="font-family: &#39;courier new&#39;, courier;">y</span><em>,</em> a proste rzutowania biegły równoległe do osi <span style="font-family: &#39;courier new&#39;, courier;">z</span>.&nbsp; Narysowany w ten sposób czajnik wygląda tak jak na rysunku 1.</p><p class="MsoNormal przedmioty">&nbsp;</p><div align="justify"><div align="center">&nbsp;<img src="./GK Lab4 - Zakład Systemów Komputerowych_files/open_6_1.jpg" border="0" alt=" "></div><div style="text-align: center;" align="center">Rys. 1. Czajnik w rzucie ortograficznym<br><br></div><div style="text-align: justify;" align="center">Ze względu na to, że proste rzutowania są równoległe do osi <em><strong>z</strong></em>, przesuwanie obiektu wzdłuż tej osi nie spowoduje żadnego efektu na obrazie. Aby umożliwić pokazanie efektów przemieszczeń obiektu we wszystkich osiach nalely zastosować rzutowanie perspektywiczne. Rzut perspektywiczny jest lepszy od równoległego nie tylko ze względu na możliwość prezentacji przemieszczeń, pozwala także lepiej pokazać na płaszczyźnie geometrii trójwymiarowego obiektu.</div><div style="text-align: justify;" align="justify">Biblioteka <em>OpenGL</em> daje kilka możliwości definiowania rzutu perspektywicznego. Jedną z nich prezentuje szablon programu zamieszczony niżej.</div><div align="justify"><p class="MsoNormal kod kod">&nbsp;</p><p class="MsoNormal kod kod"><span class="kod" style="font-family: &#39;courier new&#39;, courier;">/*************************************************************************************/</span></p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">// &nbsp;Szkielet programu do tworzenia modelu sceny 3-D z wizualizacją osi&nbsp; </span><br><span style="font-family: &#39;courier new&#39;, courier;">//&nbsp; układu współrzędnych dla rzutowania perspektywicznego</span></p><p class="MsoNormal kod kod"><span class="kod" style="font-family: &#39;courier new&#39;, courier;">/*************************************************************************************/</span></p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">#include &lt;windows.h&gt;</span><br><span style="font-family: &#39;courier new&#39;, courier;">#include &lt;gl/gl.h&gt;</span><br><span style="font-family: &#39;courier new&#39;, courier;">#include &lt;gl/glut.h&gt;</span></p><p class="MsoNormal kod kod"><br><span style="font-family: &#39;courier new&#39;, courier;">typedef float point3[3];</span></p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">static GLfloat viewer[]= {0.0, 0.0, 10.0}; </span><br><span style="font-family: &#39;courier new&#39;, courier;">// inicjalizacja położenia obserwatora</span></p><p class="MsoNormal kod kod"><span class="kod" style="font-family: &#39;courier new&#39;, courier;">/*************************************************************************************/</span></p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">// Funkcja rysująca osie układu wspó?rz?dnych</span></p><p class="MsoNormal kod kod">&nbsp;</p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">void Axes(void)</span><br><span style="font-family: &#39;courier new&#39;, courier;">{</span></p><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">point3&nbsp; x_min = {-5.0, 0.0, 0.0};</span><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">point3&nbsp; x_max = { 5.0, 0.0, 0.0};<br>// pocz?tek i koniec obrazu osi x<br></span><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">point3&nbsp; y_min = {0.0, -5.0, 0.0}; <br>point3&nbsp; y_max = {0.0,&nbsp; 5.0, 0.0};<br>// pocz?tek i koniec obrazu osi y<br><br>point3&nbsp; z_min = {0.0, 0.0, -5.0};<br>point3&nbsp; z_max = {0.0, 0.0,&nbsp; 5.0};<br>// &nbsp;pocz?tek i koniec obrazu osi y<br></span></blockquote><blockquote><span style="font-family: &#39;courier new&#39;, courier;"><span class="kod">glColor3f(1.0f, 0.0f, 0.0f);&nbsp; // kolor rysowania osi - czerwony<br></span><span class="kod">glBegin(GL_LINES); // rysowanie osi x</span></span></blockquote><blockquote><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glVertex3fv(x_min);<br>glVertex3fv(x_max);</span></blockquote></blockquote><blockquote><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">glEnd();</span><br><br><span style="font-family: &#39;courier new&#39;, courier;">glColor3f(0.0f, 1.0f, 0.0f);&nbsp; // kolor rysowania - zielony</span><br><span style="font-family: &#39;courier new&#39;, courier;">glBegin(GL_LINES);&nbsp; // rysowanie osi y</span></p></blockquote><blockquote><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glVertex3fv(y_min);<br>glVertex3fv(y_max);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></blockquote></blockquote><blockquote><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">glEnd();</span><br><br><span style="font-family: &#39;courier new&#39;, courier;">glColor3f(0.0f, 0.0f, 1.0f);&nbsp; // kolor rysowania - niebieski</span><br><span style="font-family: &#39;courier new&#39;, courier;">glBegin(GL_LINES); // rysowanie osi z</span></p></blockquote><blockquote><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glVertex3fv(z_min);<br>glVertex3fv(z_max);</span></blockquote></blockquote><blockquote><p class="MsoNormal kod"><span style="font-family: &#39;courier new&#39;, courier;">glEnd();</span></p></blockquote><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">}</span></p><p class="MsoNormal kod kod"><span class="kod" style="font-family: &#39;courier new&#39;, courier;">/*************************************************************************************/</span></p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">// Funkcja określająca co ma być rysowane (zawsze wywoływana, gdy trzeba </span><br><span style="font-family: &#39;courier new&#39;, courier;">// przerysować scenę)</span></p><p class="MsoNormal kod kod">&nbsp;</p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">void RenderScene(void)</span><br><span style="font-family: &#39;courier new&#39;, courier;">{</span></p><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">&nbsp;glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br>// Czyszczenie okna aktualnym kolorem czyszczącym<br><br>glLoadIdentity();<br>// Czyszczenie macierzy bie??cej</span><br><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">gluLookAt(viewer[0],viewer[1],viewer[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);<br>// Zdefiniowanie położenia obserwatora<br></span></blockquote><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">Axes();<br>// Narysowanie osi przy pomocy funkcji zdefiniowanej powyżej </span></blockquote><blockquote><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glColor3f(1.0f, 1.0f, 1.0f);<br>// Ustawienie koloru rysowania na biały<br><br>glutWireTeapot(3.0);<br>// Narysowanie czajnika </span></blockquote><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glFlush();</span><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">// Przekazanie poleceń rysujących do wykonania</span></blockquote><p class="MsoNormal"><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;<span class="Apple-tab-span" style="white-space: pre;"> </span>&nbsp; &nbsp;glutSwapBuffers();</span></p><p class="MsoNormal">&nbsp;</p><p class="MsoNormal kod kod"><span class="kod" style="font-family: &#39;courier new&#39;, courier;">&nbsp;}</span><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">/*************************************************************************************/</span></p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">// Funkcja ustalająca stan renderowania</span></p><p class="MsoNormal kod kod">&nbsp;</p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">void MyInit(void)</span><br><span style="font-family: &#39;courier new&#39;, courier;">{</span></p><p class="MsoNormal kod kod" style="margin-left: 35.4pt;"><span style="font-family: &#39;courier new&#39;, courier;">glClearColor(0.0f, 0.0f, 0.0f, 1.0f);</span><br><span style="font-family: &#39;courier new&#39;, courier;">// Kolor czyszczący (wypełnienia okna) ustawiono na czarny</span></p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">}</span></p><p class="MsoNormal kod kod"><span class="kod" style="font-family: &#39;courier new&#39;, courier;">/*************************************************************************************/</span></p><span class="kod" style="font-family: &#39;courier new&#39;, courier;"><span class="kod"><span class="kod"><br></span></span></span><p class="kod"><span style="font-family: &#39;courier new&#39;, courier;">// Funkcja ma za zadanie utrzymanie stałych proporcji rysowanych </span><br><span style="font-family: &#39;courier new&#39;, courier;">// w przypadku zmiany rozmiarów okna.</span><br><span style="font-family: &#39;courier new&#39;, courier;">// Parametry vertical i horizontal (wysokość i szerokość okna) są&nbsp;</span><br><span style="font-family: &#39;courier new&#39;, courier;">// przekazywane do funkcji za każdym razem gdy zmieni się rozmiar okna.</span></p><p class="kod">&nbsp;</p><p class="kod"><span style="font-family: &#39;courier new&#39;, courier;">void ChangeSize(GLsizei horizontal, GLsizei vertical)</span><br><span style="font-family: &#39;courier new&#39;, courier;">{</span><br><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp; &nbsp;glMatrixMode(GL_PROJECTION);</span><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp; &nbsp;// Przełączenie macierzy bieżącej na macierz projekcji</span><br><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp;&nbsp; glLoadIdentity();</span><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp; &nbsp;// Czyszcznie macierzy bieżącej </span><br><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp; &nbsp;gluPerspective(70, 1.0, 1.0, 30.0);</span><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp; &nbsp;// Ustawienie parametrów dla rzutu perspektywicznego</span><br><br><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp; &nbsp;if(horizontal &lt;= vertical)</span><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;glViewport(0, (vertical-horizontal)/2, horizontal, horizontal);</span><br><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp; &nbsp;else</span><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;glViewport((horizontal-vertical)/2, 0, vertical, vertical);</span><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp; &nbsp;// Ustawienie wielkości okna okna widoku (viewport) w zależności</span><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp; &nbsp;// relacji pomiędzy wysokością i szerokością okna</span><br><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp; &nbsp;glMatrixMode(GL_MODELVIEW);</span><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp; &nbsp;// Przełączenie macierzy bieżącej na macierz widoku modelu &nbsp;</span><br><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp; &nbsp;glLoadIdentity();</span><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp; &nbsp;// Czyszczenie macierzy bieżącej </span><br><br><span style="font-family: &#39;courier new&#39;, courier;">}</span></p></div><div align="justify"><p class="MsoNormal kod kod kod"><span class="kod" style="font-family: &#39;courier new&#39;, courier;">/*************************************************************************************/</span></p><p class="MsoNormal kod kod kod"><span style="font-family: &#39;courier new&#39;, courier;">// Główny punkt wejścia programu. Program działa w trybie konsoli</span></p><p class="MsoNormal kod kod kod">&nbsp;</p><p class="MsoNormal kod kod kod"><span style="font-family: &#39;courier new&#39;, courier;">void main(void)</span><br><span style="font-family: &#39;courier new&#39;, courier;">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><blockquote><span style="font-family: &#39;courier new&#39;, courier;">glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB |GLUT_DEPTH);</span><br><br><span style="font-family: &#39;courier new&#39;, courier;">glutInitWindowSize(300, 300);</span><br><br><span style="font-family: &#39;courier new&#39;, courier;">glutCreateWindow("Rzutowanie perspektywiczne");</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><span style="font-family: &#39;courier new&#39;, courier;">glutDisplayFunc(RenderScene);</span><br><span style="font-family: &#39;courier new&#39;, courier;">// Określenie, że funkcja RenderScene będzie funkcją zwrotną</span><br><span style="font-family: &#39;courier new&#39;, courier;">// (callback function).&nbsp; Będzie ona wywoływana za każdym razem </span><br><span style="font-family: &#39;courier new&#39;, courier;">// gdy zajdzie potrzeba przerysowania okna</span></blockquote><p class="MsoNormal">&nbsp;</p><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glutReshapeFunc(ChangeSize);<br>// Dla aktualnego okna ustala funkcję zwrotną odpowiedzialną<br>// za zmiany rozmiaru okna&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></blockquote><p class="MsoNormal">&nbsp;</p><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">MyInit();<br>// Funkcja MyInit() (zdefiniowana powyżej) wykonuje wszelkie<br>// inicjalizacje konieczne&nbsp; przed przystąpieniem do renderowania </span></blockquote><blockquote><span style="font-family: &#39;courier new&#39;, courier;">glEnable(GL_DEPTH_TEST);</span><br><span style="font-family: &#39;courier new&#39;, courier;">// Włączenie mechanizmu usuwania niewidocznych elementów sceny</span><br><br><span style="font-family: &#39;courier new&#39;, courier;">glutMainLoop();</span><br><span style="font-family: &#39;courier new&#39;, courier;">// Funkcja uruchamia szkielet biblioteki GLUT</span></blockquote><p><span style="font-family: &#39;courier new&#39;, courier;">}</span></p><p><span style="font-family: &#39;courier new&#39;, courier;">/*************************************************************************************/</span></p><p>&nbsp;</p>&nbsp; Po wykonaniu programu uzyskuje się obraz, który pokazano na rysunku 2. Obiekt jak widać wygląda trochę inaczej niż ten z poprzedniego rysunku i chyba bardziej przypomina swój trójwymiarowy pierwowzór.</div><div align="justify"><p>&nbsp;</p></div><div align="center">&nbsp;<img src="./GK Lab4 - Zakład Systemów Komputerowych_files/open_6_2.jpg" border="0" alt=" "></div><div align="center">Rys. 2. Czajnik w rzucie perspektywicznym<br><br></div><div align="justify">&nbsp; Zamieszczony powyżej kod programu jast bardzo podobny do tego, który być używany dla przypadku rzutowania ortograficznego w poprzednim ćwiczeniu. Różnią się od niego jednak w trzech miejscach:</div><div align="justify"><ul><li>Na pocztąku programu wprowadzono nową zmienną globalną&nbsp;<span style="font-family: &#39;courier new&#39;, courier;">viewer[]</span>. <br>Jest to tablica składająca się z trzech liczb, które określają współrz?dne <span style="font-family: &#39;courier new&#39;, courier;">x</span>, <span style="font-family: &#39;courier new&#39;, courier;">y</span>, <span style="font-family: &#39;courier new&#39;, courier;">z</span>, położenia obserwatora.<br><br></li><li>W funkcji <span style="font-family: &#39;courier new&#39;, courier;">RenderScene()</span>, przed wywołaniem funkcji definiujących rysowane obiekty, umieszczono nową funkcję&nbsp;<span style="font-family: &#39;courier new&#39;, courier;">gluLookAt()</span>. Jest to funkcja, która w prosty sposób pozwala na definiowanie położenia obserwatora trzymającego hipotetyczną kamerę. Składnia jej jest następująca:</li></ul><div align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family: &#39;courier new&#39;, courier;">void gluLookAt(GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ,</span><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GLdouble centerX, GLdouble centerY, GLdouble centerZ, &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span></div></div><div align="justify"><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GLdouble upX , GLdouble upY, GLdouble upZ);</span><br><blockquote>Jak widać, funkcja ma&nbsp;9 argumentów. Pierwsze trzy określają współrzędne punktu, w którym umieszczony jest obserwator. Trzy kolejne definiują punkt, na który obserwator patrzy, a ostatnia trójka wektor pozwalający na podanie skrócenia trzymanej przez obserwatora kamery. W przykładzie obserwator znajduje się w punkcie<span style="font-family: &#39;courier new&#39;, courier;"> (viewer[0], viewer[1], viewer[2]) = (0, 0, 10)</span> i patrzy na środek układu współrzędnych, czyli punkt (0, 0, 0). Hipotetyczna kamera jest ustawiona natomiast tak, że jej oś&nbsp;<span style="font-family: &#39;courier new&#39;, courier;">y</span> pokrywa się z osią&nbsp;y układu współrzędnych. Ostatnie argumenty funkcji mają więc wartości <span style="font-family: &#39;courier new&#39;, courier;">(upX, upY, upZ) = (0, 1, 0)</span>.</blockquote><ul><li><p>W funkcji <span style="font-family: &#39;courier new&#39;, courier;">ChangeSize()</span>,<strong> </strong>w miejsce <span style="font-family: &#39;courier new&#39;, courier;">glOrtho() </span>zastosowano<strong> </strong>funkcję<span style="font-family: &#39;courier new&#39;, courier;">&nbsp;gluPerspective()</span>, która służy do definiowania obszaru (bryły) widoczności dla rzutu perspektywicznego. Funkcja zdefiniowana jest tak:<br><br><span style="font-family: &#39;courier new&#39;, courier;">void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar)</span><br><br>Widok bryły i interpretację poszczególnych argumentów funkcji pokazano na rys. 3. Dwa widoczne na nim prostokąty,&nbsp; określają granice w jakich elementy wchodzące w skład opisu sceny będą widoczne na obrazie. Te fragmenty sceny, które leżą przed mniejszym i za większym prostokątem nie zostaną wyświetlone.<br><br></p></li></ul></div><div align="justify"><div align="center">&nbsp;<img src="./GK Lab4 - Zakład Systemów Komputerowych_files/open_6_3.jpg" border="0" alt=" " width="537" height="274"></div><div align="center"><blockquote>Rys. 3. Bryła widoczności dla rzutu perspektywicznego<br><br></blockquote><div align="justify"><p style="text-align: justify;">&nbsp;Jak widać, pełne zdefiniowanie rzutu perspektywicznego nie jest aż takie proste. Należy podać&nbsp;<span style="font-family: &#39;courier new&#39;, courier;">13</span> parametrów, <span style="font-family: &#39;courier new&#39;, courier;">9</span> dla określenia sposobu patrzenia (ustawienia syntetycznej kamery) w funkcji <span style="font-family: &#39;courier new&#39;, courier;">gluLookAt()</span> i <span style="font-family: &#39;courier new&#39;, courier;">4</span> dla zdefiniowania właściwości kamery (kąta patrzenia i zakresu obcinania) w funkcji <span style="font-family: &#39;courier new&#39;, courier;">gluPerspective()</span>. Jednak przy pewnej wprawie i odrobinie wyobraźni, przyjęta koncepcja pozwala na intuicyjne i w miarę wygodne manipulowanie widokiem.</p><p style="text-align: justify;">&nbsp;</p><p style="text-align: justify;">Dla przykładu jeśli zmienić ustawienie obserwatora z:</p><blockquote><p><span class="kod" style="font-family: &#39;courier new&#39;, courier;">gluLookAt(0.0, 0.0, 10.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0);</span></p></blockquote><p>na</p><blockquote><p class="kod"><span style="font-family: &#39;courier new&#39;, courier;">gluLookAt(<span style="color: #ff0000;"><strong>3.0, 3.0</strong><span style="color: #000000;">, 10.0</span></span>, 0.0, 0.0, 0.0, 1.0, <strong><span style="color: #ff0000;">1.0, 0.0</span></strong>);</span></p><p>&nbsp;</p></blockquote><p>czyli lekko unieść i przesunąć kamerę w prawo <span style="font-family: &#39;courier new&#39;, courier;">((<strong>viewer[</strong>0<strong>]</strong>, <strong>viewer[</strong>1<strong>], </strong><strong>viewer[</strong>2<strong>]</strong>) = (0, 0, 10))</span> z jednoczesnym jej obrotem o 45 stopni <span style="font-family: &#39;courier new&#39;, courier;">(upX, upY, upZ) = (1, 1, 0)</span> uzyskany na ekranie obraz będzie wyglądał tak jak na rys. 4.<br><br><br><br></p><p align="center">&nbsp;<img src="./GK Lab4 - Zakład Systemów Komputerowych_files/open_6_4.jpg" border="0" alt=" "></p></div></div></div><div align="center">Rys. 4.&nbsp; Czajnik widziany z innego punktu obserwacji i przy przekr?conej kamerze<br><br></div><div align="justify">&nbsp;Na rysunku pojawiła się oś&nbsp;<em><strong>z </strong></em>(niebieska). Oś ta zdefiniowana była od początku w funkcji <span style="font-family: &#39;courier new&#39;, courier;">Axes() </span>ale na żadnym z poprzednich rysunków nie było jej widać.</div><h4 align="justify">3. Przykład sposobu realizacji prostej interakcji</h4><div align="justify"><p class="MsoNormal przedmioty">Na początek zostanie pokazane, jak zrealizować zadanie, które polega na obracaniu czajnika przy pomocy myszy. Zadanie można sformułować tak:</p><ul><li>Narysować czajnik w położeniu początkowym, tak aby wyglądać jak na rys. 2.<br><br></li><li>W przypadku wciśnięcia lewego klawisza myszy, przesuwanie kursora myszy w prawo powinno powodować obrót czajnika wokół osi <em><strong>y</strong></em> w prawo. <br><br></li><li>W przypadku <span>wciśnięcia&nbsp;</span>lewego klawisza myszy, przesuwanie kursora myszy w lewo&nbsp; powinno powodować obrót czajnika wokół osi <em><strong>y</strong></em> w lewo.</li></ul></div><div align="justify">&nbsp;Trzeba&nbsp; wyraźnie zaznaczyć, że pożądany efekt można uzyskać na <span style="color: #000000;"><strong>dwa</strong></span> sposoby. (1) Można obracać obiekt wokół osi przy ustalonym położeniu przy ustalonym położeniu obserwatora. (2) Można także obracać obserwatora wokół obiektu. W tym przypadku zastała wybrana (1) metoda.<br><br>&nbsp; Aby osiągnąć założony efekt, należy dokonać kilku modyfikacji podanego na początku opisu ćwiczenia kodu:</div><div align="justify"><ol><li>W sekcji opisującej zmienne globalne dodać nowe zmienne:<br><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">static GLfloat theta = 0.0;&nbsp;&nbsp; // kąt obrotu obiektu</span><br><span class="kod"><span class="kod" style="font-family: &#39;courier new&#39;, courier;">static GLfloat pix2angle;&nbsp;&nbsp;&nbsp;&nbsp; // przelicznik pikseli na stopnie</span><br><span class="kod"><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">static GLint status = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>// stan klawiszy myszy </span><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>// 0 - nie naciśnięto żadnego klawisza</span><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>// 1 - naciśnięty zostać lewy klawisz</span><br><span class="kod"><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">static int x_pos_old=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // poprzednia pozycja kursora myszy</span><br><span class="kod"><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">static int delta_x = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>// różnica pomiędzy pozycją bieżącą</span><br><span class="kod"><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>&nbsp; &nbsp; &nbsp;&nbsp;<span class="Apple-tab-span" style="white-space: pre;"> </span>// i poprzednią kursora myszy</span> <br></span><br><br></span></span></span></span></li><li>Dodać dwie nowe funkcje zwrotne:<br><br><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">/*************************************************************************************/</span><br><span style="font-family: &#39;courier new&#39;, courier;"><span class="kod"><span class="kod">// Funkcja "bada" stan myszy i ustawia wartości odpowiednich zmiennych globalnych</span><br><span class="kod"><br><span class="kod">void Mouse(int btn, int state, int x, int y)</span><br><span class="kod">{</span><br><span class="kod"><br><span class="kod"><br><span class="kod">&nbsp;&nbsp;&nbsp; if(btn==GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_DOWN)&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </span><br><span class="kod">&nbsp;&nbsp;&nbsp; {</span><br><span class="kod">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; x_pos_old=x;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span class="Apple-tab-span" style="white-space: pre;"> </span> // przypisanie aktualnie odczytanej pozycji kursora </span><br><span class="kod">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>// jako pozycji poprzedniej</span><br><span class="kod">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; status = 1;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>// wcięnięty został lewy klawisz myszy</span><br><span class="kod">&nbsp;&nbsp;&nbsp; }<span class="Apple-tab-span" style="white-space: pre;"> </span></span><br><span class="kod">&nbsp;&nbsp;&nbsp; else</span><br><span class="kod"><br><span class="kod">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; status = 0;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>// nie został wcięnięty żaden klawisz </span><br><span class="kod">}</span><br><span class="kod"><br><span class="kod"></span></span></span></span></span></span></span><span class="kod">/*************************************************************************************/</span><span class="kod"><span class="kod"><span class="kod"><span class="kod"><span class="kod"><span class="kod"><span class="kod"></span><br><span class="kod"><span class="kod">// Funkcja "monitoruje" położenie kursora myszy i ustawia wartości odpowiednich </span><br><span class="kod">// zmiennych </span><span class="kod">globalnych</span><br><span class="kod"><br><span class="kod">void Motion( GLsizei x, GLsizei y )</span><br><span class="kod">{</span><br><span class="kod">&nbsp;&nbsp;&nbsp; </span><br><span class="kod">&nbsp;&nbsp;&nbsp; delta_x=x-x_pos_old;&nbsp;&nbsp;&nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>// obliczenie różnicy położenia kursora myszy</span><br><span class="kod"><br><span class="kod">&nbsp;&nbsp;&nbsp; x_pos_old=x;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span class="Apple-tab-span" style="white-space: pre;"> </span>// podstawienie bieżącego położenia jako poprzednie</span><br><span class="kod"><br><span class="kod">&nbsp;&nbsp;&nbsp; glutPostRedisplay();&nbsp;&nbsp;&nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>// przerysowanie obrazu sceny</span><br><span class="kod">}<br></span><br><span class="kod"></span></span></span></span></span></span></span></span></span></span></span><span class="kod">/*************************************************************************************/</span></span><span class="kod"><span class="kod"><span class="kod"><span class="kod"><span class="kod"><span class="kod"><span class="kod"><span class="kod"><span class="kod"><span class="kod"><span class="kod"></span><br><br><br></span></span></span></span></span></span></span></span></span></span></li><li>Zarejestrować dodane funkcje zwrotne w funkcji <span style="font-family: &#39;courier new&#39;, courier;">main()</span>,<strong> </strong>dopisując dwie linie kodu:<br><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glutMouseFunc(Mouse);<br>// Ustala funkcję zwrotną odpowiedzialną za badanie stanu myszy<br>&nbsp; &nbsp; <br>glutMotionFunc(Motion);<br>// Ustala funkcję zwrotną odpowiedzialną za badanie ruchu myszy<br></span><br><br></li><li><span style="font-family: tahoma, arial, helvetica, sans-serif;">W funkcji <span style="font-family: &#39;courier new&#39;, courier;">ChangeSize() </span>(najlepiej na samym początku) dodać linię:</span><br><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">pix2angle = 360.0/(float)horizontal; <span class="Apple-tab-span" style="white-space: pre;"> </span>// przeliczenie pikseli na stopnie<br></span><br><br></li><li><span style="font-family: tahoma, arial, helvetica, sans-serif;">W funkcji <span style="font-family: &#39;courier new&#39;, courier;">RenderScene()</span> po wywołaniu funkcji rysującej osie a przed funkcję rysującą czajnik dodać:</span><br><br><span style="font-family: &#39;courier new&#39;, courier;">i<span class="kod">f(status == 1)&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>// jeśli lewy klawisz myszy wcięnięty<br>{<br>&nbsp;&nbsp; theta += delta_x*pix2angle;&nbsp;&nbsp;&nbsp; // modyfikacja kąta obrotu o kat proporcjonalny<br>}&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>// do różnicy położeń kursora myszy<br><br>glRotatef(theta, 0.0, 1.0, 0.0);&nbsp; //obrót obiektu o nowy kąt</span></span></li></ol></div><div style="text-align: justify;" align="justify"><span class="kod"><br></span>&nbsp; Tak zmodyfikowany kod pozwoli na zrealizowanie zadania sterowania obrotami w lewo i prawo przy pomocy myszy. Należy zauważyć, że sterowanie odbywa się przez modyfikację kąta obrotu nie przez aktualne położenie myszy, a różnicę pomiędzy położeniem bieżącym i poprzednim. Podane rozwiązanie umożliwia lepszą stabilizację ruchu obiektu i uniknięcie skokowych zmian w generowanym obrazie w przypadku nieciągłego ruchu myszy. Jest to rozwiązanie godne polecenia także w innych zadaniach polegających na przenoszeniu ruchu myszy na ruch obiektu na scenie.</div><h4 style="text-align: justify;" align="justify">4. Zadania do wykonania</h4><div align="justify"><p class="MsoNormal przedmioty"><strong><span style="text-decoration: underline;">Zadanie 1.</span></strong>&nbsp;Należy zmodyfikować poprzednio napisany program tak aby:</p></div><ul><li>Po uruchomieniu programu czajnik był rysowany w położeniu początkowym.</li></ul><ul><li>Przy wciśniętym lewym klawiszu myszy, ruch kursora myszy w kierunku poziomym powodować obroty czajnika wokół osi <em><strong>y</strong></em> (tak jak w poprzednim przykładzie).</li></ul><ul><li>Przy <span>wciśniętym</span> lewym klawiszu myszy, ruch kursora myszy w kierunku pionowym powodować obroty czajnika wokół osi <em><strong>x</strong></em> .</li></ul><ul><li>Przy <span>wciśniętym</span> prawym klawiszu myszy, ruchy kursora myszy w kierunku pionowym wywoływać zbliżanie i oddalanie się obserwatora od czajnika (swoisty rodzaj funkcji zoom).</li></ul></div><div align="justify"><strong><span style="text-decoration: underline;">Zadanie 2.</span></strong>&nbsp;Jako obiektu w miejsce czajnika, użyć zbudowanego w poprzednim ćwiczeniu modelu jajka a następnie zmodyfikować napisany wcześniej kod tak, aby można było oglądać jajko ze zmieniającego się punktu widzenia.</div><div align="justify">Sterowanie położeniem obserwatora powinno odbywać się przy pomocy myszy, przy następujących założeniach:</div><div align="justify"><ul><li>&nbsp;Jajko znajduje się jest w środku układu współrzędnych.<br><br></li><li>Punkt, w którym umieszczony jest obserwator może poruszać się po powierzchni sfery o promieniu <em><strong>R </strong></em>i środku leżącym w środku układu współrzędnych.<br><br></li><li>Sterowanie położeniem obserwatora odbywa się powinno przy pomocy dwóch kątów. <br>Pierwszy z nich określa kierunek patrzenia na obiekt i nosi nazwę&nbsp;<strong>azymutu</strong> i&nbsp; oznaczany będzie dalej jako <strong><em>Θ</em></strong>. Drugi oznaczony przez <em><strong>Φ</strong>,<strong> </strong></em>określa pośrednio wysokość położenia obserwatora nad hipotetycznym horyzontem i nazywa się kątem <strong>elewacji</strong> (elewacja określa w astronomii wysokość na jakiej gwiazda jest położona nad horyzontem). Odpowiedni układ geometryczny został zilustrowany na rys. 5.</li></ul></div><div align="justify"><br><br><div align="center"><img src="./GK Lab4 - Zakład Systemów Komputerowych_files/open_6_5.jpg" border="0" alt=" "></div></div><div align="justify"><div style="text-align: center;" align="center">Rys. 5.&nbsp; Obiekt, obserwator i kąty azymutu oraz elewacji</div><div style="text-align: justify;" align="center"><br><br>Na podstawie rys. 5 można dość łatwo wyznaczyć zależności wiążące położenie obserwatora z azymutem, kątem elewacji i promieniem sfery na powierzchni, której znajduje się obserwator. Są one następujące:</div></div><blockquote><p align="justify">&nbsp;</p><p>&nbsp;</p><p align="center"><img src="./GK Lab4 - Zakład Systemów Komputerowych_files/open_6_6.jpg" border="0" alt=" "></p></blockquote><p align="justify">Ostatecznie zadanie brzmi tak:</p><ul><li>Po uruchomieniu programu, jajko powinno zostać narysowane w położeniu początkowym.</li></ul><ul><li>Przy wciśniętym lewym klawiszu myszy, ruch kursora myszy w kierunku poziomym powinien powodować proporcjonalną zmianę azymutu kąta <strong><em>Θ</em></strong>.</li></ul><ul><li>Przy wciśniętym lewym klawiszu myszy, ruch kursora myszy w kierunku pionowym powinien powodować proporcjonalną zmianę kąta elewacji <em><strong>Φ</strong>.</em></li></ul><ul><li>Przy wciśniętym prawym klawiszu myszy, ruchy kursora myszy w kierunku pionowym winien realizować zmianę promienia <em><strong>R</strong></em>.</li></ul><p>&nbsp; W ten sposób, jeśli parametry zmieniające położenie kursora myszy na kąty i promień zostaną prawidłowo dobrane, obserwator będzie mógł zobaczyć jak wygląda jajko z każdej strony.</p><p>&nbsp;</p><p align="center">&nbsp;<strong>Zadania domowe</strong></p><p align="center"><strong><br></strong></p><div align="center">&nbsp;<a href="http://www.zsk.ict.pwr.wroc.pl/zsk/repository/dydaktyka/gk/zadania_domowe/zadania_4.pdf"><img src="./GK Lab4 - Zakład Systemów Komputerowych_files/pdf1.gif" border="0" alt="pdf1.gif" title="pdf1.gif" width="16" height="16"></a></div><p align="center">&nbsp;</p><p>Ćwiczenie opracował:&nbsp; Jacek Jarnicki, korekta Marek Woda (2017-11-08)</p><p>&nbsp;</p></div>
          <div class="articleBack"><a href="javascript:history.back()">Powrót</a></div>
        </div>
      </div>
      <div id="right">
        <div></div>
      </div>
      <div id="footer">
        <div id="footer-copyright">Copyright © 2020 Zakład Systemów Komputerowych</div>
        <div></div>
      </div>
      <div id="additional">
        <div id="stats"><img id="stat" src="./GK Lab4 - Zakład Systemów Komputerowych_files/stat.gif" height="1" width="1" alt="" hidden="" style="display: none !important;"></div>
        <div id="extra"></div><div id="extra2"></div><div id="extra3"></div><div id="extra4"></div>
      </div>
    </div>
  


</body></html>