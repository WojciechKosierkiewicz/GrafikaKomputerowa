<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0061)http://www.zsk.ict.pwr.wroc.pl/zsk/dyd/intinz/gk/lab/cw_3_dz/ -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Zespół Systemów Komputerowych</title>
    <script type="text/javascript" src="./GK Lab3 - Zespół Systemów Komputerowych_files/stats.js"></script>
    
    <meta http-equiv="Content-Style-Type" content="text/css">
    <meta name="description" content="Zespół Systemów Komputerowych">
    <meta name="keywords" content="zespół systemów komputerowych, zsk, politechnika wrocławska, pwr, wrocław, ict, instytut cybernetyki technicznej, instytut informatyki, automatyki i robotyki">
    <meta name="robots" content="index, follow">
    <meta name="author" content="Tomasz Walkowiak">
    <meta name="copyright" content="Copyright © 2020 Zakład Systemów Komputerowych">
    <link href="./GK Lab3 - Zespół Systemów Komputerowych_files/main.css" rel="stylesheet" type="text/css">
    <link rel="shortcut icon" href="http://www.zsk.ict.pwr.wroc.pl/zsk/css/001/favicon.ico" type="image/x-icon">
  </head>

  <body id="cms" onload="stats(326)">
    <div id="loginout">
      <form method="post" action="http://www.zsk.ict.pwr.wroc.pl/zsk/login.do">
        <div class="headlog">
          <input name="userLogin" type="text" value="">
          <input name="userPassword" type="password" value="">
          <input id="submit" type="submit" value="Zaloguj">
        </div>
      </form>
    </div>
    <div id="container">
      <div id="header">
        <div class="mainMenu">
          <div><p><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/projekty/">Działalność naukowo-badawcza</a></p></div>
          <div><p><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/dyd/">Działalność dydaktyczna</a></p></div>
          <div><p><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/pracownicy/">Pracownicy</a></p></div>
          <div><p><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/news/">Aktualności</a></p></div>
          <div><p><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/eng/">English version</a></p></div>
        </div>
      </div>
      <div id="left">
        <div class="catalogMenu">
          <div><p><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/dyd/intinz/gk/lab/">..</a></p></div>
        </div>
      </div>
      <div id="content">
        <div class="content">
          <div class="itemPath"><span><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/dyd/">Działalność dydaktyczna</a></span><span><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/dyd/intinz/">Studia inżynierskie</a></span><span><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/dyd/intinz/gk/">Grafika komputerowa</a></span><span><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/dyd/intinz/gk/lab/">Laboratorium - studia stacjonarne</a></span><span><a href="http://www.zsk.ict.pwr.wroc.pl/zsk/dyd/intinz/gk/lab/cw_3_dz/">Ćwiczenie 3</a></span></div>
          <div class="articleTitle">Ćwiczenie 3</div>
          <div class="articleDescription">OpenGL - modelowanie obiektów 3-D</div>
          <div class="articleContent"><h4 class="MsoNormal przedmioty">1. Cel ćwiczenia</h4><p class="MsoNormal" style="text-align: justify;">&nbsp; Celem ćwiczenia jest wprowadzenie w zagadnienia modelowania i wizualizacji scen 3D z wykorzystaniem biblioteki <span style="font-family: &#39;courier new&#39;, courier;">OpenGL</span> z rozszerzeniem <span style="font-family: &#39;courier new&#39;, courier;"><strong>GLUT</strong></span>. Zamieszczone w treści opisu ćwiczenia przykłady pokazują jak w układzie współrzędnych trójwymiarowych wykonuje się&nbsp; transformacje obiektów oraz jak na podstawie równań parametrycznych można stworzyć własny model nietrywialnego obiektu. Przy okazji pokazano także sposób sterowania wykonaniem programu przy pomocy klawiatury oraz prosty przykład z zakresu animacji. &nbsp;</p><h4 class="MsoNormal"><span class="przedmioty">2. Układ współrzędnych i obiekt 3D</span></h4><p class="MsoNormal">&nbsp;</p><p class="MsoNormal" style="text-align: justify;" align="justify">&nbsp; W środowisku programistycznym MSVisual Studio utworzyć (w ten sam sposób jak w poprzednim ćwiczeniu) nowy projekt i w pliku źródłowym umieścić kod zamieszczony niżej. Program tworzy okno graficzne i rysuje obrazy osi układu współrzędnych 3-D.&nbsp; Rysunek osi może być pomocny w wielu przypadkach tworzenia scen 3-D, zwłaszcza w początkowej fazie zaznajamiania się z biblioteką OpenGL. Obraz osi <strong>x</strong><em><strong> </strong></em>rysowany jest kolorem czerwonyn,&nbsp; osi <strong>y</strong><em><strong> </strong></em>zielonym a osi <strong>z </strong>niebieskim. Ze względu na fakt, że w przykładzie wykorzystano rzutowanie ortograficzne (proste rzutowania przecinają rzutnię pod kątem prostym) obraz osi<strong> z </strong>nie jest widoczny.</p><p class="MsoNormal">&nbsp;</p><p class="MsoNormal kod kod"><span class="kod" style="font-family: &#39;courier new&#39;, courier;">/*************************************************************************************/</span></p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">// &nbsp;Szkielet programu do tworzenia modelu sceny 3-D z wizualizacją osi&nbsp; </span><br><span style="font-family: &#39;courier new&#39;, courier;">//&nbsp; układu współrzednych</span></p><p class="MsoNormal kod kod"><span class="kod" style="font-family: &#39;courier new&#39;, courier;">/*************************************************************************************/</span></p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">#include &lt;windows.h&gt;</span><br><span style="font-family: &#39;courier new&#39;, courier;">#include &lt;gl/gl.h&gt;</span><br><span style="font-family: &#39;courier new&#39;, courier;">#include &lt;gl/glut.h&gt;</span></p><p class="MsoNormal kod kod"><br><span style="font-family: &#39;courier new&#39;, courier;">typedef float point3[3]; </span></p><p class="MsoNormal kod kod"><span class="kod" style="font-family: &#39;courier new&#39;, courier;">/*************************************************************************************/</span></p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">// Funkcja rysująca osie układu współrzędnych</span></p><p class="MsoNormal kod kod">&nbsp;</p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">void Axes(void)</span><br><span style="font-family: &#39;courier new&#39;, courier;">{</span></p><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">point3&nbsp; x_min = {-5.0, 0.0, 0.0};</span><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">point3&nbsp; x_max = { 5.0, 0.0, 0.0};<br>// początek i koniec obrazu osi x<br></span><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">point3&nbsp; y_min = {0.0, -5.0, 0.0}; <br>point3&nbsp; y_max = {0.0,&nbsp; 5.0, 0.0};<br>// początek i koniec obrazu osi y<br><br>point3&nbsp; z_min = {0.0, 0.0, -5.0};<br>point3&nbsp; z_max = {0.0, 0.0,&nbsp; 5.0};<br>// &nbsp;początek i koniec obrazu osi y<br></span></blockquote><blockquote><span style="font-family: &#39;courier new&#39;, courier;"><span class="kod">glColor3f(1.0f, 0.0f, 0.0f);&nbsp; // kolor rysowania osi - czerwony<br></span><span class="kod">glBegin(GL_LINES); // rysowanie osi x</span></span></blockquote><blockquote><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glVertex3fv(x_min);<br>glVertex3fv(x_max);</span></blockquote></blockquote><blockquote><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">glEnd();</span><br><br><span style="font-family: &#39;courier new&#39;, courier;">glColor3f(0.0f, 1.0f, 0.0f);&nbsp; // kolor rysowania - zielony</span><br><span style="font-family: &#39;courier new&#39;, courier;">glBegin(GL_LINES);&nbsp; // rysowanie osi y</span></p></blockquote><blockquote><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glVertex3fv(y_min);<br>glVertex3fv(y_max);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></blockquote></blockquote><blockquote><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">glEnd();</span><br><br><span style="font-family: &#39;courier new&#39;, courier;">glColor3f(0.0f, 0.0f, 1.0f);&nbsp; // kolor rysowania - niebieski</span><br><span style="font-family: &#39;courier new&#39;, courier;">glBegin(GL_LINES); // rysowanie osi z</span></p></blockquote><blockquote><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glVertex3fv(z_min);<br>glVertex3fv(z_max);</span></blockquote></blockquote><blockquote><p class="MsoNormal kod"><span style="font-family: &#39;courier new&#39;, courier;">glEnd();</span></p></blockquote><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">}</span></p><p class="MsoNormal kod kod"><span class="kod" style="font-family: &#39;courier new&#39;, courier;">/*************************************************************************************/</span></p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">// Funkcja określająca co ma być rysowane (zawsze wywoływana gdy trzeba </span><br><span style="font-family: &#39;courier new&#39;, courier;">// przerysować scenę)</span></p><p class="MsoNormal kod kod">&nbsp;</p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">void RenderScene(void)</span><br><span style="font-family: &#39;courier new&#39;, courier;">{</span></p><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">&nbsp;glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br>// Czyszczenie okna aktualnym kolorem czyszczącym<br><br>glLoadIdentity();<br>// Czyszczenie macierzy bieżącej<br></span></blockquote><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">Axes();<br>// Narysowanie osi przy pomocy funkcji zdefiniowanej wyżej</span></blockquote><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glFlush();</span><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">// Przekazanie poleceń rysujących do wykonania</span></blockquote><p class="MsoNormal">&nbsp;</p><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glutSwapBuffers();</span><br><span style="font-family: &#39;courier new&#39;, courier;">//</span></blockquote><p class="MsoNormal kod kod"><span class="kod" style="font-family: &#39;courier new&#39;, courier;">&nbsp;}<br></span><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">/*************************************************************************************/</span></p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">// Funkcja ustalająca stan renderowania</span></p><p class="MsoNormal kod kod">&nbsp;</p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">void MyInit(void)</span><br><span style="font-family: &#39;courier new&#39;, courier;">{</span></p><p class="MsoNormal kod kod" style="margin-left: 35.4pt;"><span style="font-family: &#39;courier new&#39;, courier;">glClearColor(0.0f, 0.0f, 0.0f, 1.0f);</span><br><span style="font-family: &#39;courier new&#39;, courier;">// Kolor czyszcący (wypełnienia okna) ustawiono na czarny</span></p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">}</span></p><p class="MsoNormal kod kod"><span class="kod" style="font-family: &#39;courier new&#39;, courier;">/*************************************************************************************/</span></p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">// Funkcja ma za zadanie utrzymanie stałych proporcji rysowanych </span><br><span style="font-family: &#39;courier new&#39;, courier;">// w przypadku zmiany rozmiarów okna.</span><br><span style="font-family: &#39;courier new&#39;, courier;">// Parametry vertical i horizontal (wysokość i szerokość okna) są </span><br><span style="font-family: &#39;courier new&#39;, courier;">// przekazywane do funkcji za każdym razem gdy zmieni się rozmiar okna.</span></p><p class="MsoNormal kod kod">&nbsp;</p><p class="MsoNormal kod kod"><span style="font-family: &#39;courier new&#39;, courier;">void ChangeSize(GLsizei horizontal, GLsizei vertical )</span><br><span style="font-family: &#39;courier new&#39;, courier;">{</span></p><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">GLfloat AspectRatio;<br>// Deklaracja zmiennej AspectRatio &nbsp;określającej proporcję<br>// wymiarów okna</span>&nbsp;</blockquote><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">if(vertical == 0)&nbsp; // Zabezpieczenie przed dzieleniem przez 0<br></span><blockquote><span style="font-family: &#39;courier new&#39;, courier;">vertical = 1;&nbsp;</span>&nbsp;</blockquote></blockquote><blockquote><span style="font-family: &#39;courier new&#39;, courier;">glViewport(0, 0, horizontal, vertical);</span><br><span style="font-family: &#39;courier new&#39;, courier;">// Ustawienie wielkościokna okna widoku (viewport)</span><br><span style="font-family: &#39;courier new&#39;, courier;">// W tym przypadku od (0,0) do (horizontal, vertical)&nbsp;</span>&nbsp;</blockquote><blockquote><span style="font-family: &#39;courier new&#39;, courier;">glMatrixMode(GL_PROJECTION);</span><br><span style="font-family: &#39;courier new&#39;, courier;">// Przełączenie macierzy bieżącej na macierz projekcji</span>&nbsp;</blockquote><blockquote><span style="font-family: &#39;courier new&#39;, courier;">glLoadIdentity();</span><br><span style="font-family: &#39;courier new&#39;, courier;">// Czyszcznie macierzy bieżącej &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span>&nbsp;</blockquote><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;"><span class="kod">AspectRatio = (GLfloat)horizontal/(GLfloat)vertical;</span><br>// Wyznaczenie współczynnika&nbsp; proporcji okna<br>// Gdy okno nie jest kwadratem wymagane jest określenie tak zwanej<br>// przestrzeni ograniczającej pozwalającej zachować właściwe<br>// proporcje rysowanego obiektu.<br>// Do okreslenia przestrzeni ograniczjącej służy funkcja<br>// glOrtho(...) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span>&nbsp;</blockquote><blockquote><p class="MsoNormal kod kod kod kod kod"><span style="font-family: &#39;courier new&#39;, courier;">if(horizontal &lt;= vertical)</span></p><blockquote><span style="font-family: &#39;courier new&#39;, courier;">glOrtho(-7.5,7.5,-7.5/AspectRatio,7.5/AspectRatio,10.0, -10.0);&nbsp;</span></blockquote></blockquote><blockquote><p class="MsoNormal kod kod kod"><span class="kod" style="font-family: &#39;courier new&#39;, courier;">else</span></p><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glOrtho(-7.5*AspectRatio,7.5*AspectRatio,-7.5,7.5,10.0,-10.0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></blockquote></blockquote><blockquote><p class="MsoNormal kod kod kod"><span style="font-family: &#39;courier new&#39;, courier;">glMatrixMode(GL_MODELVIEW);</span><br><span style="font-family: &#39;courier new&#39;, courier;">// Przełączenie macierzy bieżącej na macierz widoku modelu &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p></blockquote><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glLoadIdentity();<br>// Czyszcenie macierzy bieżącej</span></blockquote><p><span class="kod" style="font-family: &#39;courier new&#39;, courier;"><span class="kod"><span class="kod">}</span></span></span></p><p class="MsoNormal kod kod kod"><span class="kod" style="font-family: &#39;courier new&#39;, courier;">/*************************************************************************************/</span></p><p class="MsoNormal kod kod kod"><span style="font-family: &#39;courier new&#39;, courier;">// Główny punkt wejścia programu. Program działa w trybie konsoli</span></p><p class="MsoNormal kod kod kod">&nbsp;</p><p class="MsoNormal kod kod kod"><span style="font-family: &#39;courier new&#39;, courier;">void main(void)</span><br><span style="font-family: &#39;courier new&#39;, courier;">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p><blockquote><span style="font-family: &#39;courier new&#39;, courier;">glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB |GLUT_DEPTH);</span><br><br><span style="font-family: &#39;courier new&#39;, courier;">glutInitWindowSize(300, 300);</span><br><br><span style="font-family: &#39;courier new&#39;, courier;">glutCreateWindow("Układ współrzędnych 3-D");</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><span style="font-family: &#39;courier new&#39;, courier;">glutDisplayFunc(RenderScene);</span><br><span style="font-family: &#39;courier new&#39;, courier;">// Określenie, że funkcja RenderScene będzie funkcją zwrotną</span><br><span style="font-family: &#39;courier new&#39;, courier;">// (callback function).&nbsp; Bedzie ona wywoływana za każdym razem </span><br><span style="font-family: &#39;courier new&#39;, courier;">// gdy zajdzie potrzba przeryswania okna</span>&nbsp;</blockquote><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glutReshapeFunc(ChangeSize);<br>// Dla aktualnego okna ustala funkcję zwrotną odpowiedzialną<br>// zazmiany rozmiaru okna &nbsp; &nbsp;&nbsp;</span>&nbsp;</blockquote><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">MyInit();<br>// Funkcja MyInit() (zdefiniowana powyżej) wykonuje wszelkie<br>// inicjalizacje konieczne&nbsp; przed przystąpieniem do renderowania </span></blockquote><blockquote><span style="font-family: &#39;courier new&#39;, courier;">glEnable(GL_DEPTH_TEST);</span><br><span style="font-family: &#39;courier new&#39;, courier;">// Włączenie mechanizmu usuwania powierzchni niewidocznych</span><br><br><span style="font-family: &#39;courier new&#39;, courier;">glutMainLoop();</span><br><span style="font-family: &#39;courier new&#39;, courier;">// Funkcja uruchamia szkielet biblioteki GLUT</span></blockquote><p><span style="font-family: &#39;courier new&#39;, courier;">}</span></p><p><span class="kod" style="font-family: &#39;courier new&#39;, courier;">/*************************************************************************************/</span></p><p class="MsoNormal"><br>&nbsp; Efekt działania programu pokazany został na rysunku 1.</p><p class="MsoNormal">&nbsp;</p><p class="MsoNormal">&nbsp;</p><p class="MsoNormal" align="center">&nbsp;<img src="./GK Lab3 - Zespół Systemów Komputerowych_files/open_5_1.jpg" border="0" alt=" "></p><p class="MsoNormal" align="center">Rys. 1 Układ współrzędnych w 3-D (rzutowanie ortograficzne)</p><p class="MsoNormal" align="center">&nbsp;</p><p class="MsoNormal" align="center">&nbsp;</p><div align="justify">&nbsp; Uzyskany obraz nie jest może zbyt ciekawy, ale można go łatwo wzbogacić wprowadzając w funkcji <span style="font-family: &#39;courier new&#39;, courier;">RenderScene()</span>, po linii z wywołaniem funkcji rysującej osie<span style="font-family: &#39;courier new&#39;, courier;"> Axes()</span> dwie nowe linie kodu:</div><p class="MsoNormal">&nbsp;</p><blockquote><p class="MsoNormal kod"><span style="font-family: &#39;courier new&#39;, courier;">glColor3f(1.0f, 1.0f, 1.0f); // Ustawienie koloru rysowania na biały</span></p></blockquote><blockquote><p class="MsoNormal kod"><span style="font-family: &#39;courier new&#39;, courier;">glutWireTeapot(3.0); // Narysowanie obrazu czajnika do herbaty</span><br><br></p></blockquote><p>&nbsp; &nbsp;Po uruchomieniu zmodyfikowanego programu otrzymuje się obraz taki jak na rysunku 2.</p><p class="MsoNormal">&nbsp;</p><p class="MsoNormal">&nbsp;</p><p class="MsoNormal" align="center">&nbsp;<img src="./GK Lab3 - Zespół Systemów Komputerowych_files/open_5_2.jpg" border="0" alt=" "></p><p class="MsoNormal" align="center">Rys. 2 Czajnik do herbaty w położeniu początkowym</p><p class="MsoNormal" align="center">&nbsp;</p><p class="MsoNormal" align="center">&nbsp;</p><p class="MsoNormal" style="text-align: justify;" align="justify">&nbsp; Funkcja<span style="font-family: &#39;courier new&#39;, courier;"> glutWireTeapot()</span><strong> </strong>jest jedną z ponad dwudziestu funkcji biblioteki <em>GLUT</em> pozwalających na łatwe rysowanie obiektów 3D. Jest to funkcja dość szczególna, bowiem czajnik jako obiekt zdecydowanie asymetryczny nadaje się bardzo dobrze do śledzenia rezultatów zastosowanych transformacji. Pokazany na rysunku 2 czajnik występuje w literaturze grafiki komputerowej bardzo często Jest to jeden z najbardziej popularnych i lubianych przez Autorów przykładów. Inne obiekty, jakie oferuje biblioteka <em>GLUT</em> to:</p><p class="MsoNormal kod">&nbsp;</p><p class="MsoNormal"><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga4">glutSolidCone</a> </strong>(GLdouble base, GLdouble height, GLint slices, GLint stacks)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga1">glutSolidCube</a></strong> (GLdouble width)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga6">glutSolidCylinder</a> </strong>(GLdouble radius, GLdouble height, GLint slices, GLint stacks)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga11">glutSolidDodecahedron</a> </strong>(void)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga17">glutSolidIcosahedron</a></strong> (void)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga13">glutSolidOctahedron</a></strong> (void)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga19">glutSolidRhombicDodecahedron</a> </strong>(void)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga21">glutSolidSierpinskiSponge</a> </strong>(int num_levels, const GLdouble offset[3], GLdouble scale)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga2">glutSolidSphere</a></strong> (GLdouble radius, GLint slices, GLint stacks)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga23">glutSolidTeapot</a></strong> (GLdouble size)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga15">glutSolidTetrahedron</a> </strong>(void)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga9">glutSolidTorus</a> </strong>(GLdouble dInnerRadius, GLdouble dOuterRadius, GLint nSides, GLint nRings)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga5">glutWireCone</a> </strong>(GLdouble base, GLdouble height, GLint slices, GLint stacks)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga0">glutWireCube</a></strong> (GLdouble width)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga7">glutWireCylinder</a></strong> (GLdouble radius, GLdouble height, GLint slices, GLint stacks)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga10">glutWireDodecahedron</a> </strong>(void)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga16">glutWireIcosahedron</a></strong> (void)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga12">glutWireOctahedron</a> </strong>(void)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga18">glutWireRhombicDodecahedron</a></strong> (void)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga20">glutWireSierpinskiSponge</a></strong> (int num_levels, const GLdouble offset[3], GLdouble scale)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga3">glutWireSphere</a></strong> (GLdouble radius, GLint slices, GLint stacks)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga22">glutWireTeapot</a></strong> (GLdouble size)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga14">glutWireTetrahedron</a></strong> (void)<br><strong><a href="http://openglut.sourceforge.net/group__geometry.html#ga8">glutWireTorus</a></strong> (GLdouble dInnerRadius, GLdouble dOuterRadius, GLint nSides, GLint nRings)</p><p class="MsoNormal">&nbsp;</p><h4 class="MsoNormal">3. Transformacje w przestrzeni 3-D</h4><p class="MsoNormal przedmioty" style="text-align: justify;">&nbsp; Przemieszczania obiektu w przestrzeni 3D realizuje się używając formalnego aparatu transformacji geometrycznych. Najwygodniejszą formą przedstawienia transformacji jest macierz, w związku z tym wszelkie operacje związane z transformacjami w bibliotece OpenGL wykonuje się stosując operacje rachunku macierzowego. Dokładniejsze wyjaśnienie zagadnień związanych z ideą zastosowania macierzy i ich implementacją w OpenGL znaleźć można w literaturze i dokumentacjach biblioteki. Dla potrzeb niniejszego ćwiczenia podanych zostanie jedynie tylko kilka funkcji pozwalających w prosty sposób manipulować położeniem obiektów. Funkcjami tymi są:</p><p class="MsoNormal" align="justify">&nbsp;</p><p class="MsoNormal" align="justify">&nbsp;</p><p><span style="font-family: &#39;courier new&#39;, courier;">glMatrixMode(GLenum mode);E</span></p><p><span style="font-family: &#39;courier new&#39;, courier;">glLoadIdenty(void);</span></p><p><span style="font-family: &#39;courier new&#39;, courier;">glTranslated(TYP x, TYPE y, TYPE z);</span></p><p><span style="font-family: &#39;courier new&#39;, courier;">glScaled(TYPE x, TYPE y, TYPE z);</span></p><p><span style="font-family: &#39;courier new&#39;, courier;">glRotated(TYPE angle, TYPE x, TYPE y, TYPE z,);</span></p><p>&nbsp;</p><p class="MsoNormal" align="justify">&nbsp; Dwie pierwsze funkcje<span style="font-family: &#39;courier new&#39;, courier;"> glMatrixMode()</span> i <span style="font-family: &#39;courier new&#39;, courier;">glLoadIdenty()</span> nie ralizują konkretnych tansformacji, pełnią natomiast ważną rolę organizacyjną w procesie przetwarzania danych geometrycznych sceny.<br><br>&nbsp; Funkcja <span style="font-family: &#39;courier new&#39;, courier;">glMatrixMode()</span> ustala która z macierzy stanowiących elementy ciągu procedury wizualizacji&nbsp; będzie tak zwaną macierzą bieżącą, czyli macierzą, która będzie dalej modyfikowna aż do następnej ewentualnej zmiany macierzy bieżącej. Moliwe są trzy wartości argumentu funkcji: <span style="font-family: &#39;courier new&#39;, courier;">GL_MODELVIEW</span>, <span style="font-family: &#39;courier new&#39;, courier;">GL_PROJECTION</span>&nbsp;i&nbsp;<span style="font-family: &#39;courier new&#39;, courier;">GL_TEXTURE</span><strong>. </strong>Jeśli argumentem bedzie <span style="font-family: &#39;courier new&#39;, courier;">GL_MODELVIEW </span>modyfikowana będzie macierz widoku modelu (odpowiedzialana za przeliczanie geometrii modelu). W przypadku argumentu <span style="font-family: &#39;courier new&#39;, courier;">GL_PROJECTION</span> nastepne operacje macierzowe dotyczyć bedą macierzy projekcji (odpowiedzialnej za rzutowanie). Trzeci przypadek <span style="font-family: &#39;courier new&#39;, courier;">GL_TEXTURE</span> dotyczy tekstury i zostanie omówiony przy okazji innego ćwiczenia.</p><p class="MsoNormal" align="justify">&nbsp; Funkcja <span style="font-family: &#39;courier new&#39;, courier;">glLoadIdenty()</span> ''czyści" macierz bieżącą (ustawioną przez funkcję&nbsp;<span style="font-family: &#39;courier new&#39;, courier;">glMatrixMode()</span>. Formalnie sprowadza się to do ustawienia macierzy bieżącej jako macierzy jednostkowej.<br><br>&nbsp; Kolejne dwie funkcje <span style="font-family: &#39;courier new&#39;, courier;">glTranslated()</span> i <span style="font-family: &#39;courier new&#39;, courier;">glScaled()</span> służą do wykonywania translacji i skalowania natoniast funkcja <span style="font-family: &#39;courier new&#39;, courier;">glRotated(angle, x, y, z)</span> relaizuje obrót o kąt angle wokół osi wyznacznej przez punkt (0, 0, 0) czyli środek układu współrzędnych i punkt (x, y, z).<br><br>Dla przykładu obrót czajnika o 60 stopni wokół osi wyznaczonej przez punkty (0, 0, 0) i (1, 1, 1) realizuje następujący fragment kodu:<br><br></p><blockquote><p class="kod"><span style="font-family: &#39;courier new&#39;, courier;">glRotated(60.0, 1.0, 1.0, 1.0 );&nbsp; // Obrót o 60 stopni</span></p><p class="kod">&nbsp;</p><p class="kod"><span style="font-family: &#39;courier new&#39;, courier;">glutWireTeapot(3.0); // Narysowanie obrazu czajnika do herbaty</span></p></blockquote><p>&nbsp;</p><p>&nbsp; Efekt operacji transformacji obrotu ilustruje rysunek 3</p><p>&nbsp;</p><p>&nbsp;</p><p align="center"><img src="./GK Lab3 - Zespół Systemów Komputerowych_files/open_5_3.jpg" border="0" alt=" "></p><p style="text-align: center;" align="justify">&nbsp;Rys. 3 Czajnik do herbaty obrócony o 60 stopni wokół osi wyznaczonej przez wektor [1&nbsp; 1&nbsp; 1]</p><p class="MsoNormal">&nbsp;</p><p class="MsoNormal">&nbsp;</p><p class="MsoNormal" align="justify">&nbsp; Biblioteka <em>OpenGL</em> oferuje jescze&nbsp;szereg innych funkcji pozwalających&nbsp;w szcególności&nbsp;na definowanie własnych macierzy, wykonywanie operacji macierzowych, składania przekształceń na stos i pobieranie ich ze stosu oraz innych. Szczegóły można znaleźć w dokumentacji.&nbsp;</p><h4 class="MsoNormal przedmioty" align="justify">4. Budowa własnego modelu obiektu 3-D</h4><p class="MsoNormal przedmioty" align="justify">&nbsp; Modelowanym obiektem będzie jajko określone jako powierzchnia opisana równaniami parmetrycznymi. Na wykładzie pokazano jak przy pomocy obrócenia odpowiednio dobranej krzywej Beziera można uzyskać wzory opisujące powierzchnię jajka. Wzory te wygladają następująco:</p><p align="justify">&nbsp;</p><div align="center"><img src="./GK Lab3 - Zespół Systemów Komputerowych_files/open_5_5.jpg" border="0" alt=" " width="705" height="139"><br><br><br></div><p align="justify">&nbsp; Rysunek 4 ilustruje ideę budowy powierzchni opisanej równaniami parametrycznymi.</p><p align="center">&nbsp;</p><p align="center"><img src="./GK Lab3 - Zespół Systemów Komputerowych_files/open_5_4.jpg" border="0" alt=" "></p><p align="center">&nbsp;</p><p align="center">Rys. 4 Przekształcenie dziedziny parametrycznej w powierzchnię w przestrzeni 3D</p><p align="center">&nbsp;</p><p style="text-align: justify;" align="justify">&nbsp; Pierwszym zadaniem jest wygenerowanie chmury&nbsp; punktów leżących na powierzchni obiektu. Algorytm generacji zbioru punktów polega na pokryciu dziedziny parametrycznej (kwadratu jednostkowego w przestrzeni <strong>u</strong>, <strong>v</strong>) równomierną siatką punktów a następnie przeliczeniu współrzędnych poszcególnych punktów siatki z dziedziny parametrycznej, na punkty w przestrzeni trójwymiarowej. Do przeliczenia będą służyły wyżej podane równania. <br><br>Szkic algorytmu można zapisać tak:</p><ol><li><div align="justify">Zadać&nbsp;liczbę<strong> N</strong>, która określała będzie na ile przedziałów podzielony zostanie&nbsp;bok kwadratu jednostkowego dziedziny parametrycznej. <br><br></div></li><li><div align="justify">Zadeklarować tablicę o rozmiarze <strong>NxN</strong>, która będzie służyła do zapisywania&nbsp;współrzednych punktów&nbsp;w przestrzeni 3-D. Każdy element tablicy zawierał będzie trzy liczby będące współrzędnymi <span style="font-family: &#39;courier new&#39;, courier;">x</span><strong>, </strong><span style="font-family: &#39;courier new&#39;, courier;">y</span><strong>, </strong><span style="font-family: &#39;courier new&#39;, courier;">z</span> jednego punktu.<br><br></div></li><li><div align="justify">&nbsp;Nałożyć na kwadrat jednostkowy dziedziny parametrycznej równomierną siatkę <strong>NxN </strong>punktów.<br><br></div></li><li><div align="justify">Dla każdego punktu <span style="font-family: &#39;courier new&#39;, courier;">u</span><strong>, </strong><span style="font-family: &#39;courier new&#39;, courier;">v</span> nałożonej w kroku poprzednim siatki, obliczyć, przy pomocy podanych wyżej rówanań współrzędne <span style="font-family: &#39;courier new&#39;, courier;">x(u, v),</span>&nbsp;<span style="font-family: &#39;courier new&#39;, courier;">y(u, v)</span> i <span style="font-family: &#39;courier new&#39;, courier;">z(u, v)</span> i zapisać je w zadeklarowanej w kroku 2 tablicy.<br><br></div></li><li><div align="justify">Wyświetlić na ekranie elementy tablicy współrzędnych punktów posługując się konstrukcją:</div></li></ol><blockquote><p align="justify"><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glBegin(GL_POINTS);</span></p><p class="kod" align="justify"><span style="font-family: &#39;courier new&#39;, courier;"><strong>...</strong></span></p><p class="kod" align="justify"><span style="font-family: &#39;courier new&#39;, courier;">//wierzchołki odpowiadające punktom z tablicy współrzędnych punktów</span></p><p class="kod" align="justify"><span style="font-family: &#39;courier new&#39;, courier;"><strong>...</strong></span></p><p class="kod" align="justify"><span style="font-family: &#39;courier new&#39;, courier;">glEnd();</span></p></blockquote><p align="justify">&nbsp; Program należy napisać&nbsp; tak, aby rysowanie obrazu jajka następowało po wywołaniu odpowiedniej funkcji nazwanej na przykład <span style="font-family: &#39;courier new&#39;, courier;">Egg()</span>. Funkcja ta powinna być wywoływana wewnątrz funkcij rysującej scenę <span style="font-family: &#39;courier new&#39;, courier;">RenderScene()</span>.<br>&nbsp; Uzyskany na ekranie obraz ma wyglądać mniej więcej tak jak pokazane to zostało na rysunkach 5 i 6.&nbsp; Dla lepszej prezentacji, model przesunięto wzdłuż osi <span style="font-family: &#39;courier new&#39;, courier;">y</span> tak, by środek jajka zanlazł się w środku układu współrzednych i lekko obrócono wokół osi <span style="font-family: &#39;courier new&#39;, courier;">x</span>.</p><p align="justify">&nbsp;</p><p align="justify">&nbsp;</p><p align="center">&nbsp;<img src="./GK Lab3 - Zespół Systemów Komputerowych_files/open_5_6.jpg" border="0" alt=" "></p><p style="text-align: center;" align="justify">&nbsp;Rys. 5 Model jajka zbudowany z 400 punktów</p><div align="center">&nbsp;</div><div align="center">&nbsp;</div><div align="center"><img src="./GK Lab3 - Zespół Systemów Komputerowych_files/open_5_7.jpg" border="0" alt=" "></div><p style="text-align: center;" align="justify">&nbsp;Rys. 6&nbsp; Model jajka zbudowany z 10.000 punktów&nbsp;</p><h4>&nbsp;<span style="font-size: 1em;">5.&nbsp; Modyfikacja modelu obiektu</span></h4><p class="przedmioty" style="text-align: justify;">&nbsp; Kolejne zadanie będzie polegało na wykorzystaniu wygenerowanej w poprzednim punkcie chmury punktów do budowy modelu w postaci siatki linii i modelu zbudowanego z trójkątów. Należy także zapewnić możliwość przełącznia pomiędzy widokami poszczególnych modeli, przy pomocy klawiszy. Naciśniecie klawisza "<strong>p</strong>" powinno spowodować wyświetlenie chmury punktów, klawisza "<strong>w</strong>" modelu w postaci siatki a "<strong>s</strong>", modelu złożonego z wypełnionych trójkątów.</p><p style="text-align: justify;" align="justify">&nbsp; Wprowadzenie do programu obsługi klawiatury jest pierwszym elementem interakcji z użytkownikiem. Bardziej rozbudowane sposoby z wykorzystaniem myszy będą przedmiotem kolejnego ćwiczenia.<br>&nbsp; Aby umożliwić sterowanie wykonaniem programu przy pomocy klawiatury należy poprzednio napisany program uzupełnić o następujące elementy:</p><ol><li>Zadeklarować zmienną globalną służącą do przechowywania inforamcji o tym, który model ma być wyświetlany np.<br><br><span style="font-family: &#39;courier new&#39;, courier;">i</span><span class="kod"><span style="font-family: &#39;courier new&#39;, courier;">nt model = 1;&nbsp; // 1- punkty, 2- siatka, 3 - wypełnione trójkąty</span><br><br></span></li><li>Dodać do dotychczasowego kodu funkcję funkcję zwrotną (callback function)<br><br><span class="kod"><span style="font-family: &#39;courier new&#39;, courier;">void keys(unsigned char key, int x, int y)</span><br><span style="font-family: &#39;courier new&#39;, courier;">{</span><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp;&nbsp; if(key == 'p') model = 1;</span><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp;&nbsp; if(key == 'w') model = 2;</span><br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp;&nbsp; if(key == 's') model = 3;</span><br>&nbsp;&nbsp;&nbsp; <br><span style="font-family: &#39;courier new&#39;, courier;">&nbsp;&nbsp;&nbsp; RenderScene(); // przerysowanie obrazu sceny</span><br><span style="font-family: &#39;courier new&#39;, courier;">}</span><br><br></span></li><li>W funkcj <span style="font-family: &#39;courier new&#39;, courier;">main()</span> dodać funkcję<br><br><span class="kod"><span style="font-family: &#39;courier new&#39;, courier;">glutKeyboardFunc(keys)</span><br><br></span><div align="justify">Funkcja ta rejestruje funkcję zwrotną wywoływaną przez biblitekę <em>GLUT</em>. W analizowanym przykładzie jest to określona wyżej funkcja<span style="font-family: &#39;courier new&#39;, courier;"> keys()</span>. Po każdym nacisnięciu klawisza podawany jest jego jest kod ASCII (zmienna <span style="font-family: &#39;courier new&#39;, courier;">key</span>) i dodatkowo pozycja kursora myszy (zmienne <span style="font-family: &#39;courier new&#39;, courier;">x</span> i <span style="font-family: &#39;courier new&#39;, courier;">y</span>).<br><br></div></li><li><div align="justify">W funkcji definiującej obiekt, uzależnić sposób rysowania od wartości zmiennej <span style="font-family: &#39;courier new&#39;, courier;">model</span>&nbsp;</div></li></ol><div align="justify">&nbsp; Rysowanie modelu obiektu jako siatki, polega na odpowiednim połączeniu odcinkami punktów, znajdujących sie w tablicy punktów, która została wygenerowana w poprzednim punkcie. W kodzie rysowania siatki nalezy więc zastosować konstrucję:</div><div align="justify"><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glBegin(GL_LINES);</span><p class="kod" align="justify"><span style="font-family: &#39;courier new&#39;, courier;"><strong>...</strong></span></p><p class="kod" align="justify"><span style="font-family: &#39;courier new&#39;, courier;">//wierzchołki odpowiadające punktom z tablicy współrzędnych punktów</span><br><span style="font-family: &#39;courier new&#39;, courier;">//pobierane z tablicy w odpowiedniej kolejności</span><br><strong style="font-family: &#39;courier new&#39;, courier;">...</strong></p><p class="kod" align="justify"><span style="font-family: &#39;courier new&#39;, courier;">glEnd();</span></p></blockquote></div><div align="justify">&nbsp; Siatka powinna wyglądac mniej wiecej tak jak na pokazane to zosttało na rysunku 7.</div><div align="justify">&nbsp;</div><div align="justify">&nbsp;</div><div align="center"><img src="./GK Lab3 - Zespół Systemów Komputerowych_files/open_5_8.jpg" border="0" alt=" "></div><div align="center">Rys. 7&nbsp; Model jajka w postaci siatki powstałej z połączenia 400 punktów</div><div align="center">&nbsp;</div><div align="center">&nbsp;&nbsp;</div><div style="text-align: justify;" align="center">&nbsp; Narysowanie obiektu w postaci zbioru wypełnionych trójkątów jest trochę trudniejsze wymaga bowiem okreslenia koloru wypełniania poszczególnych trójkątów. Może być to oczywiście jeden kolor ustawiony przed rysowaniem, jedank w takim przypadku rysunek okaże się niezbyt ciekawy, bowiem na ekranie pojawi się tylko jednolicie wypełniony ustawinym wcześniej kolorem obszar. Aby uzyskać lepszy efekt można zaproponować następujące rozwiązanie:</div><div align="justify"><ol><li>Podobnie jak przy tworzeniu modelu w postaci chmury punktów, zadeklarować drugą tablicę (tablicę kolorów punktów), także o rozmiarze <strong>NxN</strong>, która bedzie służyła do zapisywania tym razem kolorów dla poszczególnych punktów siatki. Każdy element tablicy zawierał bedzie trzy liczby z przedziału <span style="font-family: &#39;courier new&#39;, courier;">[0, 1]</span> będace&nbsp; odpowiednio składowymi <strong>R</strong>, <strong>G </strong>i <strong>B</strong> koloru punktu.<br><br></li><li>Przed rysowaniem, najlepiej zaraz po staracie programu, wypełnić tablicę losowymi wartościami , które będą w niej dalej przechowywane i nie będą już zmieniane.<br><br></li><li>&nbsp;W funkcji rysującej obraz modelu w postaci wypełnionych trójkątów zastosować konstrukcję:</li></ol></div><div align="justify"><div align="justify"><blockquote><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glBegin(GL_TRIANGLES);</span><p class="kod" align="justify"><span style="font-family: &#39;courier new&#39;, courier;"><strong>&nbsp; &nbsp; ...</strong></span></p><p class="kod" align="justify"><span style="font-family: &#39;courier new&#39;, courier;"><strong></strong>&nbsp; &nbsp;//kolor następnego wierzchołka pobrany z tablicy kolorów punktów</span></p><p class="kod" align="justify"><span style="font-family: &#39;courier new&#39;, courier;">&nbsp; &nbsp;//wierzchołek trójkąta pobrany z tablicy współrzędnych punktów(wierzchołki należy pobierac w odpowiedniej kolejności)</span></p><p class="kod" align="justify"><span style="font-family: &#39;courier new&#39;, courier;"><strong>&nbsp; &nbsp; ...</strong></span></p><p class="kod" align="justify"><span style="font-family: &#39;courier new&#39;, courier;">glEnd();</span></p><p class="kod" align="justify">&nbsp;</p><p class="kod" style="text-align: justify;" align="justify">&nbsp; Jeśli kolejność wierzchołków poszczególnych trójkątów zostanie prawidłowo ustalona na ekranie powinien pokazać się obraz podobny do tego jaki pokazano na rysunku 8. Płynne przejścia pomiedzy poszczególnymi trójkątami powstały dlatego, że wierzchołki przyległych trójkątów mają przypisany ten sam kolor.</p></blockquote></div></div><div align="justify">&nbsp;</div><div align="center"><img src="./GK Lab3 - Zespół Systemów Komputerowych_files/open_5_9.jpg" border="0" alt=" "></div><div align="center">Rys. 8&nbsp; Model jajka zbudowany z losowo wypełnionych trójkątów</div><h4 class="przedmioty" align="justify">6. Wprawienie obiektu w ruch&nbsp;</h4><div align="center">&nbsp;</div><div align="justify">&nbsp; Wrażenie ruchu można uzyskać przez odpowiednio szybkie modyfikownie położenia obiektu i wyświetlanie kolejnch obrazów pokazujących go w aktualnym położeniu. W bibliotece <strong>GLUT </strong>dostępny jest mechanizm pozwalający na stosunkowo łatwe programowaie ruchu obiektu na scenie. Zastosowanie go jest podobne do pokazanego już poprzednio sposobu obsługi klawiatury. Problem najlepiej zilustrować na przykładzie. Należy w nim zmodyfikować dotyczczas napisany kod programu tak, aby model jajka obracał się stale o niewielki kąt wokół każdej z osi ukladu współrzędnych. Modyfikacji można dokonać tak:</div><div align="justify"><ol><li>Zadeklarować zmienną globalną służącą do przechowywania inforamcji o aktualnym kącie obrotu modelu np.<br><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">static GLfloat theta[] = {0.0, 0.0, 0.0}; // trzy kąty obrotu</span><br><br><span style="font-family: &#39;courier new&#39;, courier;">theta[0]</span> będzie kątem obrotu wokół osi <span style="font-family: &#39;courier new&#39;, courier;">x</span>, <span style="font-family: &#39;courier new&#39;, courier;">theta[1]</span> wokół osi<span style="font-family: &#39;courier new&#39;, courier;"> y</span> a <span style="font-family: &#39;courier new&#39;, courier;">theta[2]</span> wokół osi <span style="font-family: &#39;courier new&#39;, courier;"><strong>z</strong></span>.<br><br></li><li>Dodać do dotychczasowego kodu funkcję funkcję zwrotną (callback function) na przykład taką:<br><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">void spinEgg()<br>{<br><br>&nbsp;&nbsp;&nbsp; theta[0] -= 0.5;<br>&nbsp;&nbsp;&nbsp; if( theta[0] &gt; 360.0 ) theta[0] -= 360.0;<br><br>&nbsp;&nbsp;&nbsp; theta[1] -= 0.5;<br>&nbsp;&nbsp;&nbsp; if( theta[1] &gt; 360.0 ) theta[1] -= 360.0;<br><br>&nbsp;&nbsp;&nbsp; theta[2] -= 0.5;<br>&nbsp;&nbsp;&nbsp; if( theta[2] &gt; 360.0 ) theta[2] -= 360.0;<br><br>&nbsp;&nbsp;&nbsp; glutPostRedisplay(); //odświeżenie zawartości aktualnego okna<br>}</span><br><br><br>W funkcji <span style="font-family: &#39;courier new&#39;, courier;">spinEgg()</span> użyto jeszcze jednej funkcji z bibliteki <em>GLUT</em>. Funkcja <span style="font-family: &#39;courier new&#39;, courier;">glutPostRedisplay()</span>, która przy każdorazowym wywołaniu spowoduje odświeżenie zawartości aktualnego okna graficznego.<br><div align="justify"><br><br></div></li><li><div align="justify">W funkcj <span style="font-family: &#39;courier new&#39;, courier;">main()</span> dodać funkcję<br><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glutIdleFunc(spinEgg);</span><br><br>Funkcja ta podobnie jak przy obsłudze klawiatury rejestruje funkcję zwrotną wywoływaną przez biblitekę <em>GLUT</em>. Jest to wyżej określona funkcja <span style="font-family: &#39;courier new&#39;, courier;">spinEgg()</span> modyfikująca kąty obrotu wokół osi. <br><br><br></div></li><li><div align="justify">W funkcji rysującej<span style="font-family: &#39;courier new&#39;, courier;"><strong> RenderScene()</strong></span> przed wywołaniem funkcji rysującej obiekt, czyli funkcji <span style="font-family: &#39;courier new&#39;, courier;">Egg()</span>, dodać trzy liniie kodu:<br><br><span class="kod" style="font-family: &#39;courier new&#39;, courier;">glRotatef(theta[0], 1.0, 0.0, 0.0);<br><br>glRotatef(theta[1], 0.0, 1.0, 0.0);<br><br>glRotatef(theta[2], 0.0, 0.0, 1.0);</span><br><br>spowoduje to obrócenie modelu wokół osi <span style="font-family: &#39;courier new&#39;, courier;">x</span>, <span style="font-family: &#39;courier new&#39;, courier;">y</span>, <span style="font-family: &#39;courier new&#39;, courier;">z</span> o kąty aktualnie wyliczone w funkcji <span style="font-family: &#39;courier new&#39;, courier;">spinEgg()</span>.</div></li></ol></div><div align="justify">&nbsp; W efekcie po uruchomieniu programu model jajka powinien zacząć się obracać.<br><br></div><div align="justify">&nbsp;</div><div align="center">&nbsp;<strong>Zadania domowe </strong></div><div align="center">&nbsp;</div><div align="center">&nbsp;&nbsp;</div><div align="center">&nbsp;<a href="http://www.zsk.ict.pwr.wroc.pl/zsk/repository/dydaktyka/gk/zadania_domowe/zadania_3.pdf"><img src="./GK Lab3 - Zespół Systemów Komputerowych_files/pdf1.gif" border="0" alt="pdf1.gif" title="pdf1.gif" width="16" height="16"></a></div><div align="justify">&nbsp;</div><div align="center">&nbsp;</div><div align="justify">Ćwiczenie opracował:&nbsp; Jacek Jarnicki, korekty Marek Woda (2016-10-26)&nbsp;</div></div>
          <div class="articleBack"><a href="javascript:history.back()">Powrót</a></div>
        </div>
      </div>
      <div id="right">
        <div></div>
      </div>
      <div id="footer">
        <div id="footer-copyright">Copyright © 2020 Zakład Systemów Komputerowych</div>
        <div></div>
      </div>
      <div id="additional">
        <div id="stats"><img id="stat" src="./GK Lab3 - Zespół Systemów Komputerowych_files/stat.gif" height="1" width="1" alt="" hidden="" style="display: none !important;"></div>
        <div id="extra"></div><div id="extra2"></div><div id="extra3"></div><div id="extra4"></div>
      </div>
    </div>
  


</body></html>